---
title: '프로세스와 스레드: 운영체제 핵심 원리 탐구'
date: '2025-07-22 10:52'
tags: ['OS', '프로세스', '스레드', 'CS']
---

실무를 하다 보면 어느 순간, 기초 개념을 제대로 이해하지 못한 채 흘려보냈던 부분들이 발목을 잡는 경우가 생긴다. 나 역시 그런 순간을 느끼며, 단단한 기반 위에서 더 깊이 있는 개발을 하고 싶다는 생각이 들었다. 그 시작점으로 삼은 것이 바로 운영체제의 핵심 개념인 **프로세스(Process)** 와 **스레드(Thread)** 다.

현대 컴퓨팅 환경은 다중 작업(Multi-tasking)을 기반으로 동작한다. 워드프로세서로 문서를 작성하면서도 웹 브라우저로 검색하고, 동시에 음악을 스트리밍하는 모습은 더 이상 낯설지 않다.

이러한 동시 실행의 중심에는 운영체제(OS)의 핵심 개념들이 존재한다. 이번 포스팅에서는 프로세스와 스레드의 정의, 메모리 구조, 그리고 둘 사이의 핵심적인 차이점을 정리하면서, 운영체제 개념에 대한 이해를 한층 더 탄탄하게 다져보고자 한다.

## 1. 프로세스(Process): 자원 할당의 단위

프로세스는 `실행 중인 프로그램(a program in execution)`으로 정의된다. 즉, 디스크에 정적인 파일 형태로 존재하던 프로그램이 메모리에 적재되어 운영체제의 관리를 받는 동적인 상태를 의미한다. 운영체제는 각 프로세스에 독립적인 자원을 할당하며, 이는 프로세스가 다른 프로세스의 영역을 침범하지 못하도록 하는 중요한 보호 메커니즘으로 작용한다.

### 프로세스의 메모리 구조

운영체제는 각 프로세스에 다음과 같은 구조를 갖는 고유한 가상 주소 공간(Virtual Address Space)을 할당한다.

* **코드(Code/Text) 영역**: 실행 가능한 기계어 코드가 저장되는 공간이다. 읽기 전용(Read-only)으로 설정되어 코드의 변경을 방지한다.
* **데이터(Data) 영역**: 전역 변수(global variables)와 정적 변수(static variables)가 저장된다. 프로그램 시작과 함께 할당되어 종료 시 소멸된다.
* **힙(Heap) 영역**: 프로그래머가 동적으로 메모리를 할당하는 공간이다 (`malloc()`, `new` 등). 런타임(runtime)에 크기가 결정된다.
* **스택(Stack) 영역**: 함수의 호출과 관련된 지역 변수, 매개변수, 반환 주소 등이 저장된다. 함수 호출 시 생성되고 반환 시 소멸된다.

### 프로세스 제어 블록 (Process Control Block, PCB)

운영체제는 프로세스를 관리하기 위해 `PCB`라는 자료구조를 사용한다. `PCB`는 특정 프로세스에 대한 모든 핵심 정보를 담고 있으며, 컨텍스트 스위칭(Context Switching) 시 이 정보가 활용된다.

* **프로세스 상태(Process State)**: 생성(new), 준비(ready), 실행(running), 대기(waiting), 종료(terminated) 등
* **프로세스 ID(PID)**: 각 프로세스의 고유 식별자
* **프로그램 카운터(Program Counter, PC)**: 다음에 실행될 명령어의 주소
* **CPU 레지스터 및 스케줄링 정보, 메모리 관리 정보 등**

## 2. 스레드(Thread): CPU 실행의 단위

스레드는 `프로세스 내에서 실행되는 흐름의 단위`로 정의된다. 즉, 하나의 프로세스는 하나 이상의 스레드를 가질 수 있으며, 이 스레드들은 CPU 실행의 기본 단위가 된다. 스레드는 "경량 프로세스(Lightweight Process, LWP)"라고도 불린다.

스레드는 자신이 속한 프로세스의 자원을 공유한다. 구체적으로, 한 프로세스 내의 모든 스레드는 해당 프로세스의 **코드, 데이터, 힙 영역을 공유**한다. 이는 스레드 간의 통신이 별도의 IPC(Inter-Process Communication) 기법 없이도 효율적으로 이루어질 수 있게 한다.

하지만 모든 자원을 공유하는 것은 아니다. 각 스레드는 독립적인 실행 상태를 유지하기 위해 자신만의 **프로그램 카운터(PC), 레지스터 집합, 그리고 스택(Stack)** 을 가진다. 이 때문에 한 스레드가 함수를 호출하더라도 다른 스레드의 실행 흐름에 영향을 주지 않는다.

## 3. 프로세스와 스레드의 핵심 차이점 분석

| 구분 | 프로세스 (Process) | 스레드 (Thread) |
| :--- | :--- | :--- |
| **역할** | 자원 할당의 단위 | CPU 실행(스케줄링)의 단위 |
| **메모리** | **독립된** 주소 공간 할당 (IPC 필요) | 프로세스 내 주소 공간 **공유** (Stack 제외) |
| **생성 비용**| **높음 (High Overhead)**: `fork()` 시 주소 공간 복제 등 많은 자원 소모 | **낮음 (Low Overhead)**: Stack 등 일부 자원만 할당하므로 생성 속도가 빠름 |
| **컨텍스트 스위칭**| 오버헤드가 큼 (캐시 초기화, 메모리 맵 변경) | 오버헤드가 작음 (스택 포인터, PC 등 일부 레지스터만 변경) |
| **안정성** | 높음: 한 프로세스의 오류가 다른 프로세스에 영향을 주지 않음 | 낮음: 한 스레드의 오류(예: 비정상 종료)가 전체 프로세스에 영향을 미침 |
| **통신** | IPC (Inter-Process Communication) 사용, 복잡하고 비용이 큼 | 공유 메모리를 통해 통신, 간단하지만 동기화(Synchronization) 문제 발생 가능 |

**멀티프로세싱**은 안정성이 중요한 작업(예: 크롬 브라우저의 탭 격리)에 유리하며, **멀티스레딩**은 자원 공유를 통한 높은 성능과 빠른 응답성이 필요한 작업(예: 웹 서버의 동시 요청 처리)에 적합하다.

## 마무리

프로세스는 **자원 소유의 단위**로서 독립성과 안정성을 제공하며, 스레드는 **실행의 단위**로서 공유 자원을 통해 효율성과 동시성을 높인다. 이 둘의 관계와 특성을 정확히 이해하는 것은 시스템의 성능과 안정성을 좌우하는 아키텍처를 설계하는 데 있어 중요하다. 개발자는 해결하고자 하는 문제의 특성을 분석하여 멀티프로세스와 멀티스레드 중 적절한 모델을 선택하고, 잠재적인 문제점(예: 동기화)을 예방할 수 있는 능력이 필요하다. 

## 참고 자료

* https://learn.microsoft.com/en-us/windows/win32/procthread/processes-and-threads
* https://pages.cs.wisc.edu/~remzi/OSTEP/