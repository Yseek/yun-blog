---
title: '트랜잭션 격리 수준, 내 것으로 만들기 위한 정리'
date: '2025-07-23 13:03'
tags: ['Database', 'Transaction', 'Oracle', 'MySQL', 'Backend']
---

개발자라면 누구나 한 번쯤 '트랜잭션 격리 수준'이라는 키워드로 검색을 해본 경험이 있을 거다. 검색 결과는 언제나 정리가 잘 된 수많은 기술 블로그와 공식 문서들이 쏟아져 나온다. 나 또한 여러 자료를 찾아 읽으며 고개를 끄덕이곤 했다. 

그런데 이상하게, 읽을 땐 이해한 것 같은데 막상 실제 상황에서 적용하려 하면 기억이 가물가물하거나 머릿속에서만 뱅뱅 돌 때가 많다. 눈으로만 본 지식을 다시 한 번 내 식대로 정리하며 깊이를 다져보려고 한다. 

## 1. 트랜잭션 격리 수준, 개념 정리

트랜잭션 격리 수준이란, 여러 트랜잭션이 동시에 실행될 때 각 트랜잭션이 다른 트랜잭션의 변경 내용을 얼마나 볼 수 있도록 허용할지를 결정하는 기준이다. 격리 수준이 높을수록 데이터 정합성은 완벽에 가까워지지만, 동시에 처리할 수 있는 성능(동시성)은 떨어지는 트레이드오프 관계에 있다.

격리 수준을 이야기할 때 반드시 알아야 할 3가지 현상이 있다.

* **Dirty Read**: 아직 커밋(Commit)되지 않은, 다른 트랜잭션의 변경 데이터를 읽는 현상. 해당 트랜잭션이 롤백(Rollback)되면 데이터는 무효가 되므로 심각한 정합성 문제를 야기한다.
* **Non-Repeatable Read**: 한 트랜잭션 내에서 같은 쿼리를 두 번 실행했는데, 그 사이에 다른 트랜잭션이 값을 수정하고 커밋해버려 두 쿼리의 결과가 다르게 나타나는 현상.
* **Phantom Read**: 한 트랜잭션에서 일정 범위의 데이터를 조회했는데, 다른 트랜잭션이 그 범위 안에 새로운 데이터를 추가하고 커밋하여, 이전에는 없던 '유령'같은 데이터가 두 번째 쿼리에서 나타나는 현상.

ANSI SQL 표준은 이 현상들의 허용 여부에 따라 **4가지 격리 수준**을 정의한다.

| 격리 수준          | Dirty Read | Non-Repeatable Read | Phantom Read |
| :----------------- | :--------: | :-----------------: | :----------: |
| **Read Uncommitted** |     ⭕️      |          ⭕️          |      ⭕️       |
| **Read Committed** |     ❌      |          ⭕️          |      ⭕️       |
| **Repeatable Read** |     ❌      |          ❌          |      ⭕️       |
| **Serializable** |     ❌      |          ❌          |      ❌       |

## 2. Oracle Vs MySQL(InnoDB) 비교

대표적인 RDBMS인 **Oracle**과 **MySQL**은 이 표준 격리 수준을 어떻게 구현할까? 두 데이터베이스 모두 **MVCC(Multi-Version Concurrency Control)** 메커니즘을 통해 동시성을 처리하지만, 접근 방식과 기본 전략에서 중요한 차이를 보인다.

### 핵심 비교표

| 구분             | **Oracle** | **MySQL (InnoDB)** |
| :--------------- | :--------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------- |
| **기본 격리 수준** | **Read Committed** | **Repeatable Read** |
| **지원하는 수준** | `Read Committed`, `Serializable`, `Read Only`                                            | `Read Uncommitted`, `Read Committed`, `Repeatable Read`, `Serializable` (SQL 표준 4가지 모두 지원) |
| **Dirty Read** | **어떤 수준에서도 발생 안 함** | `Read Uncommitted` 수준에서 발생                                                                     |
| **Phantom Read 방지** | `Serializable` 수준에서 방지                                                               | `Repeatable Read` 수준에서 **Gap Lock**으로 대부분 방지                                              |
| **주요 특징** | "읽는 작업은 쓰는 작업을 막지 않는다"는 원칙을 통해 잠금을 최소화하며 동시성 극대화                | 마스터-슬레이브 복제 환경에서 데이터 정합성을 보장하기 위해 `Repeatable Read`를 기본값으로 채택        |

### Oracle의 전략: 동시성에 초점

Oracle은 `Read Committed`를 기본값으로 채택하여 일반적인 상황에서 **최고의 동시성**을 제공하는 데 중점을 둔다.

* **쿼리 기준 스냅샷**: 각 쿼리가 시작되는 시점에 커밋된 데이터만 읽는다. 따라서 트랜잭션 내에서도 쿼리마다 다른 결과를 볼 수 있다 (Non-Repeatable 발생 가능).
* **Dirty Read 원천 차단**: MVCC와 Undo 데이터를 활용하여 어떤 경우에도 커밋되지 않은 데이터를 읽지 않는다. 이 덕분에 `Read Uncommitted` 수준을 아예 제공하지 않는다.
* **Serializable**: 트랜잭션 시작 시점의 스냅샷을 제공하여 완벽한 정합성을 보장한다. 하지만 이 수준에서 데이터 변경 충돌이 일어나면 `ORA-08177` 에러를 발생시키며 트랜잭션을 롤백시킨다.

### MySQL(InnoDB)의 전략: 정합성에 무게

MySQL의 InnoDB 엔진은 `Repeatable Read`를 기본값으로 채택하여 **데이터 정합성**을 더 중요하게 생각한다. 이는 과거 바이너리 로그(Binlog) 기반의 복제 환경에서 데이터 불일치를 막기 위한 역사적인 선택이기도 하다.

* **트랜잭션 기준의 스냅샷**: 트랜잭션이 시작될 때의 데이터 버전을 트랜잭션 내내 유지한다. 따라서 Non-repeatable Read가 발생하지 않는다.
* **Gap Lock으로 Phantom Read 방지**: `Repeatable Read` 수준에서도 **Gap Lock과 Next-Key Lock**이라는 독자적인 잠금 기술로 데이터와 데이터 사이의 '간격'을 잠가버린다. 이로 인해 다른 트랜잭션이 해당 범위에 새로운 데이터를 `INSERT`하는 것을 막아 Phantom Read 현상을 대부분 방지한다. 이는 표준 `Repeatable Read`보다 더 강력한 격리 수준이다.

## 정리

이렇게 개념을 다시 정리하고 비교해보니, 그동안 머릿속에서 따로따로 떠다니던 것들이 이제야 좀 정리되는 느낌이다.

* **Oracle 개발자라면**: 트랜잭션 내에서 반복 조회가 필요한 경우 데이터가 달라질 수 있음을 항상 염두에 두어야 한다.
* **MySQL 개발자라면**: 높은 수준의 정합성을 보장하지만, 이로 인한 **Gap Lock**의 동작 원리를 이해해야 예기치 못한 데드락이나 성능 저하를 피할 수 있다.

이 포스팅에 나온 Gap Lock, Next-Key Lock, MVCC 등 개념은 차후에 개별적으로 정리를 해보겠다!